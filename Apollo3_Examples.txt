Name:
=====
 i2s_loopback


Description:
============
 An example to show basic I2S operation.


Purpose:
========
This example enables the I2S interfaces to loop back data from each other.
The required pin connections are:

Printing takes place over the ITM at 1M Baud.



******************************************************************************


Name:
=====
 pdm_fft


Description:
============
 An example to show basic PDM operation.


Purpose:
========
This example enables the PDM interface to record audio signals from an
external microphone. The required pin connections are:

Printing takes place over the ITM at 1M Baud.

GPIO 50 - PDM0 CLK
GPIO 51 - PDM0 DATA

GPIO 52 - PDM1 CLK
GPIO 53 - PDM1 DATA

GPIO 54 - PDM2 CLK
GPIO 55 - PDM2 DATA

GPIO 56 - PDM3 CLK
GPIO 57 - PDM3 DATA


******************************************************************************


Name:
=====
 pdm_rtt_stream


Description:
============
 An example to show PDM audio streaming to PC over RTT data logger.


Purpose:
========
This example enables the PDM interface to record audio signals from an
external microphone. The required pin connections are:

Printing takes place over the ITM at 1M Baud.
RTT logger takes place over the SWD at 4M Baud.

Usage:
======
Build and download the program into the target device.
Reset the target and check the SWO print for PDM settings.
Run the helper script 'rtt_logger.py' in the project folder

python3 rtt_logger.py

(In this example, RTT control block is mapped to a fixed address to facilitate
the searching process. If the address is changed, make sure to modify
the rtt_logger.py script to match the address.)

During data streaming, press any key to stop the recording.
The audio captured is stored into the same folder as the rtt_logger.py,
with a file name of yyyymmdd-hh-mm-ss.pcm.

To check the audio, load the *.pcm file into audio analysis tools and check.
E.g. in Audacity, https://www.audacityteam.org/:
File -> Import -> Raw data...
Default import format is:
Signed 24-bit PCM
Little-endian
2 Channels (Stereo)
Start offset: 0 bytes
Amount to import: 100%
Sample rate: 16000 Hz


GPIO 50 - PDM0 CLK
GPIO 51 - PDM0 DATA

GPIO 52 - PDM1 CLK
GPIO 53 - PDM1 DATA

GPIO 54 - PDM2 CLK
GPIO 55 - PDM2 DATA

GPIO 56 - PDM3 CLK
GPIO 57 - PDM3 DATA



******************************************************************************


Name:
=====
 pdm_to_i2s


Description:
============
 An example to show PDM to I2S operation.


Purpose:
========
This example enables the PDM and I2S interface to collect audio signals from an
external microphone, transmit to I2S1(slave), then loop back to I2S0(master). The required pin connections are:

Printing takes place over the ITM at 1M Baud.

GPIO 50 - PDM0 CLK
GPIO 51 - PDM0 DATA

GPIO 52 - PDM1 CLK
GPIO 53 - PDM1 DATA

GPIO 54 - PDM2 CLK
GPIO 55 - PDM2 DATA

GPIO 56 - PDM3 CLK
GPIO 57 - PDM3 DATA


******************************************************************************


Name:
=====
 ble_firmware_update


Description:
============
 This is the application just for updating built-in BLE firmware into Cooper.





******************************************************************************


Name:
=====
 ble_freertos_adv_ext


Description:
============
 ARM Cordio BLE - Advertising Extension Application Example.


Purpose:
========
This example implements advertising extension within the FreeRTOS
framework. To verify extended advertising working routines.

Additional Information:
=======================
To enable debug printing, add the following project-level macro definitions.

AM_DEBUG_PRINTF
WSF_TRACE_ENABLED=1

When defined, debug messages will be sent over ITM/SWO at 1M Baud.

Note that when these macros are defined, the device will never achieve deep
sleep, only normal sleep, due to the ITM (and thus the HFRC) being enabled.


******************************************************************************


Name:
=====
 ble_freertos_amdtpc


Description:
============
 ARM Cordio BLE - AMDTP Client (Master) Example.


Purpose:
========
This example is the client (master) for the BLE Ambiq Micro
Data Transfer Protocol.  This example is meant to run on an Apollo3 EVB
along with another Apollo3 EVB serving as the server. This example provides
a UART command line interface with a simple menu that allows the user to scan,
connect and initiate data transfers from either M->S or S->M direction.

Printing takes place over the ITM at 1M Baud.



******************************************************************************


Name:
=====
 ble_freertos_ancs


Description:
============
 ARM Cordio BLE - Apple Notification Center Service (ANCS) Example.


Purpose:
========
This example implements a BLE Apple Notification Center Service
profile.

Printing takes place over the ITM at 1M Baud.


******************************************************************************


Name:
=====
 ble_freertos_atps


Description:
============
 ARM Cordio BLE - ATP Application Example.


Purpose:
========
This example implements a BLE heart rate sensor within the FreeRTOS
framework. To minimize power usage, this application is compiled without
debug printing by default (the "lp" version of this example excludes
them by default).

Additional Information:
=======================
To enable debug printing, add the following project-level macro definitions.

AM_DEBUG_PRINTF
WSF_TRACE_ENABLED=1

When defined, debug messages will be sent over ITM/SWO at 1M Baud.

Note that when these macros are defined, the device will never achieve deep
sleep, only normal sleep, due to the ITM (and thus the HFRC) being enabled.


******************************************************************************


Name:
=====
 ble_freertos_fcc_test


Description:
============
 ARM Cordio BLE - FCC test example


Purpose:
========
This example is used to put Bluetooth radio in Apollo4 into various
test mode on different channels on pressing BTN1 on the Apollo4 EVB.

Printing takes place over the ITM at 1M Baud.



******************************************************************************


Name:
=====
 ble_freertos_fit


Description:
============
 ARM Cordio BLE - Fit Application Example.


Purpose:
========
This example implements a BLE heart rate sensor within the FreeRTOS
framework. To minimize power usage, this application is compiled without
debug printing by default (the "lp" version of this example excludes
them by default).

Additional Information:
=======================
To enable debug printing, add the following project-level macro definitions.

AM_DEBUG_PRINTF
WSF_TRACE_ENABLED=1

When defined, debug messages will be sent over ITM/SWO at 1M Baud.

Note that when these macros are defined, the device will never achieve deep
sleep, only normal sleep, due to the ITM (and thus the HFRC) being enabled.


******************************************************************************


Name:
=====
 ble_freertos_locator


Description:
============
 ARM Cordio BLE - Locator Application Example.


Purpose:
========
This example implements a BLE heart rate sensor within the FreeRTOS
framework. To minimize power usage, this application is compiled without
debug printing by default (the "lp" version of this example excludes
them by default).

Additional Information:
=======================
To enable debug printing, add the following project-level macro definitions.

AM_DEBUG_PRINTF
WSF_TRACE_ENABLED=1

When defined, debug messages will be sent over ITM/SWO at 1M Baud.

Note that when these macros are defined, the device will never achieve deep
sleep, only normal sleep, due to the ITM (and thus the HFRC) being enabled.


******************************************************************************


Name:
=====
 ble_freertos_throughput


Description:
============
 ARM Cordio BLE - Ambiq Micro Throughput Example.


Purpose:
========
This example implements is based on Over-the-Air (OTA) example,
is designed to test the data transmitting thourghput.

AM_DEBUG_PRINTF
WSF_TRACE_ENABLED=1

If enabled, debug messages will be sent over ITM at 1M Baud.


******************************************************************************


Name:
=====
 ble_freertos_txpower_ctrl


Description:
============
 ARM Cordio BLE - Transmit Power Control Example


Purpose:
========
This example demonstrates the control of BLE TX power level based
on pressing Button #0 on the Apollo4 EVB.

Printing takes place over the ITM at 1M Baud.



******************************************************************************


Name:
=====
 ble_freertos_watch


Description:
============
 ARM Cordio BLE - Concurrent Master/Slave Example.


Purpose:
========
This example demonstrates an BLE application in the Central role.
That is the BLE application operates as a slave to phone master and as the
master of subordinate slave devices running freertos_fit example in this SDK.

Additional Information:
=======================
1. Printing takes place over the ITM at 1M Baud.
2. When the example powers up,
2.A. it enters advertising mode by default to wait for connection from
smart phone with Time profile, Alert Notification profile and Phone
Alert Status profile supported.
2.B. when BTN1 on Apollo4 EVB is short-pressed, if advertising is on, it
stops advertising first and then starts scanning when advertising is
stopped; if scanning is on, it stops scanning and re-start advertising
when scanning stops.
2.C. During scanning, the device (if discovered) running freertos_fit
example in this SDK will be connected and scanning will be stopped.
2.D. Repeat 2.B. and 2.C. above to connect to a new slave device running
freertos_fit example (max slaves is 3).
3. when phone (iPhone is used) connects to this example, the services of Time
profile, Alert Notification profile and Phone Alert Status profile will be


******************************************************************************


Name:
=====
 uart_ble_bridge


Description:
============
 Converts UART HCI commands to SPI.


This exapmle can be used as a way to communicate between a host chip using
UART HCI and the BLE module inside Apollo3.


******************************************************************************


Name:
=====
 emmc_bm_fatfs


Description:
============
 eMMC bare-metal FatFs example.


Purpose:
========
This example demonstrates how to use file system with eMMC device
based on the eMMC bare-metal HAL.

Additional Information:
=======================
To enable debug printing, add the following project-level macro definitions.

AM_DEBUG_PRINTF

When defined, debug messages will be sent over ITM/SWO at 1M Baud.

Note that when these macros are defined, the device will never achieve deep
sleep, only normal sleep, due to the ITM (and thus the HFRC) being enabled.


******************************************************************************


Name:
=====
 emmc_raw_block_read_write


Description:
============
 emmc raw block read and write example.


Purpose:
========
This example demonstrates how to blocking PIO and DMA read & write
APIs with eMMC device.

Additional Information:
=======================
To enable debug printing, add the following project-level macro definitions.

AM_DEBUG_PRINTF

When defined, debug messages will be sent over ITM/SWO at 1M Baud.

Note that when these macros are defined, the device will never achieve deep
sleep, only normal sleep, due to the ITM (and thus the HFRC) being enabled.


******************************************************************************


Name:
=====
 hello_world


Description:
============
 A simple "Hello World" example.


This example prints a "Hello World" message with some device info
over SWO at 1M baud. To see the output of this program, run AMFlash,
and configure the console for SWO. The example sleeps after it is done
printing.


******************************************************************************


Name:
=====
 dbi2dsi_test


Description:
============
 DSI example.


This example demonstrates how to drive a MIPI DSI panel.

1-lane DSI includes 4 signals,
* Differential clock lane - positive (CLKP)
* Differential clock lane - negative (CLKN)
* Differential data lane 0 - positive (D0P)
* Differential data lane 0 - negative (D0N).



******************************************************************************


Name:
=====
 nemadc_4layer


Description:
============
 NemaDC example.


This example demonstrates DC 4 layers overlay with global alpha blending.
* Layer0 - Red image
* Layer1 - Green image
* Layer2 - Blue image
* Layer3 - Yellow image
Global alpha value can be changed in layer*.alpha. Blendmode can be changed
in layer*.blendmode.

This example can work at two different SPI interfaces. When defined ENABLE_SPI4
in preprocessor defined symbols, this example drives panel through SPI4 interface.
When defined ENABLE_QSPI in preprocessor defined symbols, this example drives
panel through QSPI interface.


******************************************************************************


Name:
=====
 nemadc_dspi_test


Description:
============
 NemaDC example.


This example demonstrates how to drive display panel with 1P1T 2-wire
Dual-SPI interface.

1P1T 2-wire Dual-SPI interface includes 4 signals,
* Chip select (CSX)
* SPI clock (CLK)
* Data interface 0 (DATA0)
* Data interface 1 (DATA1).

During the write sequence the display controller writes one or more bytes of
information to the display module via the interface. The write sequence is
initiated when CSX is driven from high to low and ends when CSX is pulled high.
Dual-SPI reuses SPI4 DCX as the second DATA signal (DATA1), and sends 4 data
bits per clock cycle. In this example, when send commands, SPI interface works
at SPI4 mode. When send frame data, SPI interface works at Dual-SPI mode. Panel
must be set to Dual-SPI mode through writing register in panel driver IC before
sending frame data.

When define TESTMODE_EN to 1 in nemadc_dspi_test.c, this example runs at test pattern mode.
When define TESTMODE_EN to 0, this example runs at image display mode.


******************************************************************************


Name:
=====
 nemadc_qspi_test


Description:
============
 NemaDC example.


This example demonstrates how to drive display panel with Quad-SPI interface.

Quad-SPI interface includes 6 signals,
* Chip select (CSX)
* SPI clock (CLK)
* Data interface 0 (DATA0)
* Data interface 1 (DATA1).
* Data interface 2 (DATA2).
* Data interface 3 (DATA3).

Quad-SPI adds two more I/O lines (DATA2 and DATA3) and sends 4 data bits per
clock cycle. During the write sequence the display controller writes one or
more bytes of information to the display module via the interface. The write
sequence is initiated when CSX is driven from high to low and ends when CSX
is pulled high. In this example, when send commands, SPI interface works at
SPI4 mode. When send frame data, SPI interface works at Qual-SPI mode. Panel
must be set to Quad-SPI mode through configuring related pins to correct H/L
level.

When define TESTMODE_EN to 1 in nemadc_qspi_test.c, this example runs at test pattern mode.
When define TESTMODE_EN to 0, this example runs at image display mode.


******************************************************************************


Name:
=====
 nemadc_spi_test


Description:
============
 NemaDC example.


This example demonstrates how to drive a SPI4 panel.

4-wire SPI includes 4 signals,
* Chip select (CSX)
* SPI clock (CLK)
* SPI bidirectional data interface (DATA)
* Data and command switch (DCX).

During the write sequence the display controller writes one or more bytes of
information to the display module via the interface. The write sequence is
initiated when CSX is driven from high to low and ends when CSX is pulled high.
DCX is driven low while command information is on the interface and is pulled
high when data is present.

When define TESTMODE_EN to 1 in nemadc_spi_test.c, this example runs at test pattern mode.
When define TESTMODE_EN to 0, this example runs at image display mode.


******************************************************************************


Name:
=====
 nemagfx_balls_bench


Description:
============
 NemaGFX example.

This example created some random balls with alpha blending on the screen,
use
#define MAX_CIRCLE_NUM               (15)
to choose how many balls rendering on the screen

AM_DEBUG_PRINTF
If enabled, debug messages will be sent over ITM.


******************************************************************************


Name:
=====
 nemagfx_blend


Description:
============
 NemaGFX example.

brief Example that demonstrates blend feature
Blending requires a series of calculations between the source (foreground)
and destination (background)color fragments for producing the final color,
which will be written in memory.This example use a constent table inside
most of the supported blending mode.demonstrates each more every 1 second.
the dst color is nema_rgba(0xff, 0, 0, 0x80), which is red color with 50%
alpha blending, the src color is nema_rgba(0, 0, 0xff, 0x80), which is blue
color with 50% alpha blending.

Printing takes place over the ITM at 1M Baud.


******************************************************************************


Name:
=====
 nemagfx_coverflow


Description:
============
 nemagfx_coverflow example.

this exampe demostration software AA at the edge of the picture


******************************************************************************


Name:
=====
 nemagfx_font_render


Description:
============
 nemagfx_font_render example.


The example use some generated .c and .h files from the TureType font. The
<size> parameter defines the height of the font. Fonts can be monospaced
(fixed-width) or not.

AM_DEBUG_PRINTF
If enabled, debug messages will be sent over ITM.


******************************************************************************


Name:
=====
 nemagfx_gauge


Description:
============
 Example of the app running under NemaGFX guage examples

of its GuiBuilder.

AM_DEBUG_PRINTF
If enabled, debug messages will be sent over ITM.


******************************************************************************


Name:
=====
 nemagfx_grad


Description:
============
 NemaGFX example.

In computer graphics, a color gradient specifies a range of position-dependent
colors, usually used to fill a region. For example, many window managers
allow the screen background to be specified as a gradient. The colors
produced by a gradient vary continuously with the position, producing smooth
color transitions.


******************************************************************************


Name:
=====
 nemagfx_rotating_clock


Description:
============
 NemaGFX example.

this example use two frame buffer demonstrate a digital rotating clock,
with Nema GPU support, the shader effect continue shows while timer passing
need a timer to get the accurate time past.


******************************************************************************


Name:
=====
 nemagfx_rotating_crate


Description:
============
 Example of the app running nemagfx rotating_crate.

this example shows a rotating crate with texture rending support. with Nema
GPU support, it can significantly reduce the general CPU effort to calculate
the data inside the frame buffer

AM_DEBUG_PRINTF
If enabled, debug messages will be sent over ITM.


******************************************************************************


Name:
=====
 nemagfx_transition_effects


Description:
============
 Example of the app running under NemaGFX guage examples

this example use one frame buffer demonstrate two picture trasition effect,
with Nema GPU support, the effect include
NEMA_TRANS_LINEAR_H,
NEMA_TRANS_CUBE_H,
NEMA_TRANS_INNERCUBE_H,
NEMA_TRANS_STACK_H,
NEMA_TRANS_LINEAR_V,
NEMA_TRANS_CUBE_V,
NEMA_TRANS_INNERCUBE_V,
NEMA_TRANS_STACK_V,
NEMA_TRANS_FADE,
NEMA_TRANS_FADE_ZOOM,
NEMA_TRANS_MAX,
NEMA_TRANS_NONE

AM_DEBUG_PRINTF
If enabled, debug messages will be sent over ITM.


******************************************************************************


Name:
=====
 nemagfx_tsc_fb


Description:
============
 NemaGFX example.

Nemagfx_tsc_fb is a demo of TSC frame-buffer compression. The program uses
TSC4-compressed frame-buffer during run-time. It saves frame-buffer space
in RAM in a scale of 1:4 also.The demo use example NEMADC_TSC4 frame buffer
shows a 400x400 TSC4 image on the screen, it will significantly save RAM use.
Note:  the width and height of the frame-buffer should be 4-pixels aligned

AM_DEBUG_PRINTF
If enabled, debug messages will be sent over ITM.


******************************************************************************


Name:
=====
 nemagfx_watchface


Description:
============
 NemaGFX example.

this example uses two frame buffer demonstrate a digital Quartz clock, with
Nema GPU support, the shader effect continue shows while timer passing, the
function needs a timer to get the accurate time past.
AM_DEBUG_PRINTF
If enabled, debug messages will be sent over ITM.


******************************************************************************


Name:
=====
 ios_fifo


Description:
============
 Example slave used for demonstrating the use of the IOS FIFO.


Purpose:
========
This slave component runs on one EVB and is used in conjunction with
the companion host example, ios_fifo_host, which runs on a second EVB.

The ios_fifo example has no print output.
The host example does use the ITM SWO to let the user know progress and
status of the demonstration.

This example implements the slave part of a protocol for data exchange with
an Apollo IO Master (IOM).  The host sends one byte commands on SPI/I2C by
writing to offset 0x80.

The command is issued by the host to Start/Stop Data accumulation, and also
to acknowledge read-complete of a block of data.

On the IOS side, once it is asked to start accumulating data (using START
command), two CTimer based events emulate sensors sending data to IOS.
When IOS has some data for host, it implements a state machine,
synchronizing with the host.

The IOS interrupts the host to indicate data availability. The host then
reads the available data (as indicated by FIFOCTR) by READing using IOS FIFO
(at address 0x7F).  The IOS keeps accumulating any new data coming in the
background.

Host sends an acknowledgment to IOS once it has finished reading a block
of data initiated by IOS (partially or complete). IOS interrupts the host
again if and when it has more data for the host to read, and the cycle
repeats - till host indicates that it is no longer interested in receiving
data by sending STOP command.

Printing takes place over the ITM at 1M Baud.

Additional Information:
=======================
In order to run this example, a host device (e.g. a second EVB) must be set
up to run the host example, ios_fifo_host.  The two boards can be connected
using fly leads between the two boards as follows.

Pin connections for the I/O Master board to the I/O Slave board.
SPI:
HOST (ios_fifo_host)                    SLAVE (ios_fifo)
--------------------                    ----------------
GPIO[10] GPIO Interrupt (slave to host) GPIO[4]  GPIO interrupt
GPIO[5]  IOM0 SPI SCK                   GPIO[0]  IOS SPI SCK
GPIO[6]  IOM0 SPI MOSI                  GPIO[1]  IOS SPI MOSI
GPIO[7]  IOM0 SPI MISO                  GPIO[2]  IOS SPI MISO
GPIO[50] IOM0 SPI nCE                   GPIO[3]  IOS SPI nCE
GND                                     GND

I2C:
HOST (ios_fifo_host)                    SLAVE (ios_fifo)
--------------------                    ----------------
GPIO[10] GPIO Interrupt (slave to host) GPIO[4]  GPIO interrupt
GPIO[5]  IOM0 I2C SCL                   GPIO[0]  IOS I2C SCL
GPIO[6]  IOM0 I2C SDA                   GPIO[1]  IOS I2C SDA
GND                                     GND


******************************************************************************


Name:
=====
 ios_fifo_host


Description:
============
 Example host used for demonstrating the use of the IOS FIFO.


Purpose:
========
This host component runs on one EVB and is used in conjunction with
the companion slave example, ios_fifo, which runs on a second EVB.

The host example uses the ITM SWO to let the user know progress and
status of the demonstration.  The SWO is configured at 1M baud.
The ios_fifo example has no print output.

This example implements the host part of a protocol for data exchange with
an Apollo IO Slave (IOS).  The host sends one byte commands on SPI/I2C by
writing to offset 0x80.

The command is issued by the host to Start/Stop Data accumulation, and also
to acknowledge read-complete of a block of data.

On the IOS side, once it is asked to start accumulating data (using START
command), two CTimer based events emulate sensors sending data to IOS.
When IOS has some data for host, it implements a state machine,
synchronizing with the host.

The IOS interrupts the host to indicate data availability. The host then
reads the available data (as indicated by FIFOCTR) by READing using IOS FIFO
(at address 0x7F).  The IOS keeps accumulating any new data coming in the
background.

Host sends an acknowledgement to IOS once it has finished reading a block
of data initiated by IOS (partitally or complete). IOS interrupts the host
again if and when it has more data for the host to read, and the cycle
repeats - till host indicates that it is no longer interested in receiving
data by sending STOP command.

Additional Information:
=======================
In order to run this example, a slave device (e.g. a second EVB) must be set
up to run the companion example, ios_fifo.  The two boards can be connected
using fly leads between the two boards as follows.

Pin connections for the I/O Master board to the I/O Slave board.
SPI:
HOST (ios_fifo_host)                    SLAVE (ios_fifo)
--------------------                    ----------------
GPIO[10] GPIO Interrupt (slave to host) GPIO[4]  GPIO interrupt
GPIO[5]  IOM0 SPI SCK                   GPIO[0]  IOS SPI SCK
GPIO[6]  IOM0 SPI MOSI                  GPIO[1]  IOS SPI MOSI
GPIO[7]  IOM0 SPI MISO                  GPIO[2]  IOS SPI MISO
GPIO[50] IOM0 SPI nCE                   GPIO[3]  IOS SPI nCE
GND                                     GND

I2C:
HOST (ios_fifo_host)                    SLAVE (ios_fifo)
--------------------                    ----------------
GPIO[10] GPIO Interrupt (slave to host) GPIO[4]  GPIO interrupt
GPIO[5]  IOM0 I2C SCL                   GPIO[0]  IOS I2C SCL
GPIO[6]  IOM0 I2C SDA                   GPIO[1]  IOS I2C SDA
GND                                     GND


******************************************************************************


Name:
=====
 mspi_octal_example


Description:
============
 Example of the MSPI operation with Octal SPI Flash.


Purpose:
========
This example configures an MSPI connected flash device in Octal mode
and performs various operations - verifying the correctness of the same
Operations include - Erase, Write, Read, and XIP

Printing takes place over the ITM at 1M Baud.

Additional Information:
=======================
this example can work on:
Apollo3p_evb + Cygnus
Target hardware uses 1.8V power supply voltage.
Actual Octal flash on Cygnus board is ATXP128 (Device ID: 0x00A91F) instead of ATXP032
Define ADESTO_ATXP032



******************************************************************************


Name:
=====
 mspi_psram_example


Description:
============
 Example of the MSPI operation with Quad SPI PSRAM.


Purpose:
========
This example demonstrates MSPI Quad operation using the MSPI PSRAM
device.



******************************************************************************


Name:
=====
 mspi_quad_example


Description:
============
 Example of the MSPI operation with Quad SPI Flash.


Purpose:
========
This example configures an MSPI connected flash device in Quad mode
and performs various operations - verifying the correctness of the same
Operations include - Erase, Write, Read, Read using XIP Apperture and XIP.

Printing takes place over the ITM at 1M Baud.

Additional Information:
=======================
this example can work on:
Apollo3p_evb + Cygnus
Target hardware uses 1.8V power supply voltage.



******************************************************************************


Name:
=====
 mram_program


Description:
============
 MRAM programming example.


Purpose:
========
This example shows how to modify the internal MRAM using HAL
MRAM helper functions.

This example works on the portion of the MRAM at the 1MB boundary.

Printing takes place over the ITM at 1M Baud.



******************************************************************************


Name:
=====
 adc_lpmode0_dma


Description:
============
 This example takes samples with the ADC at high-speed using DMA.


Purpose:
========
This example shows the CTIMER-A3 triggering repeated samples of an external
input at 1.2Msps in LPMODE0.  The example uses the CTIMER-A3 to trigger
ADC sampling.  Each data point is 128 sample average and is transferred
from the ADC FIFO into an SRAM buffer using DMA.

Printing takes place over the ITM at 1M Baud.



******************************************************************************


Name:
=====
 binary_counter


Description:
============
 Example that displays the timer count on the LEDs.


Purpose:
========
This example increments a variable on every timer interrupt. The global
variable is used to set the state of the LEDs. The example sleeps otherwise.

Printing takes place over the ITM at 1M Baud.



******************************************************************************


Name:
=====
 hello_world


Description:
============
 A simple "Hello World" example.


This example prints a "Hello World" message with some device info
over SWO at 1M baud. To see the output of this program, run AMFlash,
and configure the console for SWO. The example sleeps after it is done
printing.


******************************************************************************


Name:
=====
 hp_mode_192mhz


Description:
============
 Example demonstrates the usage of High Performance Mode(192MHz) HAL.


Purpose:
========
This example sets the Apollo4 into Low Power Mode(96MHz), then
times a calculation of prime numbers, displaying the elapsed time. Next,
it switches the Apollo4 into High Performance Mode(192MHz), performs the
the same calculation, then displays the elapsed time, which should be
roughly 50% of Low Power Mode.

Printing takes place over the ITM at 1M Baud.



******************************************************************************


Name:
=====
 stimer


Description:
============
 Example using a stimer with interrupts.


Purpose:
========
This example demonstrates how to setup the stimer for counting and
interrupts. It toggles LED 0 to 4 every interrupt, which is set for 1 sec.

Printing takes place over the ITM at 1M Baud.



******************************************************************************


Name:
=====
 rtc_print


Description:
============
 Example using the internal RTC.


This example demonstrates how to interface with the RTC and prints the
time over SWO.

The example works by configuring a timer interrupt which will periodically
wake the core from deep sleep. After every interrupt, it prints the current
RTC time.



******************************************************************************


Name:
=====
 watchdog


Description:
============
 Example of a basic configuration of the watchdog.


Purpose:
========
This example shows a simple configuration of the watchdog. It will print
a banner message, configure the watchdog for both interrupt and reset
generation, and immediately start the watchdog timer.
The watchdog ISR provided will 'pet' the watchdog four times, printing
a notification message from the ISR each time.
On the fifth interrupt, the watchdog will not be pet, so the 'reset'
action will eventually be allowed to occur.
On the sixth timeout event, the WDT should issue a system reset, and the
program should start over from the beginning.

Printing takes place over the ITM at 1M Baud.



******************************************************************************


Name:
=====
 ble_freertos_fit_lp


Description:
============
 ARM Cordio BLE - Fit Application Example.


Purpose:
========
This example implements a BLE heart rate sensor within the FreeRTOS
framework. To minimize power usage, this application is compiled without
debug printing by default (the "lp" version of this example excludes
them by default).

Additional Information:
=======================
To enable debug printing, add the following project-level macro definitions.

AM_DEBUG_PRINTF
WSF_TRACE_ENABLED=1

When defined, debug messages will be sent over ITM/SWO at 1M Baud.

Note that when these macros are defined, the device will never achieve deep
sleep, only normal sleep, due to the ITM (and thus the HFRC) being enabled.


******************************************************************************


Name:
=====
 coremark


Description:
============
 EEMBC COREMARK test.


Purpose:
========
This example runs the official EEMBC COREMARK test.

The Coremark run begins by first outputing a banner (to the UART)
indicating that it has started.  It then does a complete disable
and power down of the UART for accurate power measuring during the run.

The Coremkark implementation performs 2000 ITERATIONS (specified in
ambiq_core_config.h), which is plenty of time for correct operation
of the benchmark.

Once the run has completed, the UART is reenabled and the results printed.

Text is output to the UART at 115,200 BAUD, 8 bit, no parity.
Please note that text end-of-line is a newline (LF) character only.
Therefore, the UART terminal must be set to simulate a CR/LF.


******************************************************************************


Name:
=====
 deepsleep


Description:
============
 Example demonstrating how to enter deepsleep.


Purpose:
========
This example configures the device to go into a deep sleep mode. Once in
sleep mode the device has no ability to wake up. This example is merely to
provide the opportunity to measure deepsleep current without interrupts
interfering with the measurement.

The example begins by printing out a banner announcement message through
the UART, which is then completely disabled for the remainder of execution.

Text is output to the UART at 115,200 BAUD, 8 bit, no parity.
Please note that text end-of-line is a newline (LF) character only.
Therefore, the UART terminal must be set to simulate a CR/LF.


******************************************************************************


Name:
=====
 deepsleep_wake


Description:
============
 Example that goes to deepsleep and wakes from either the RTC or GPIO.


Purpose:
========
This example configures the device to go into a deep sleep mode. Once in
deep sleep the RTC peripheral will wake the device every second, check to
see if 5 seconds has elapsed and then toggle LED1.

Alternatively, it will awake when button 0 is pressed and toggle LED0.

The example begins by printing out a banner annoucement message through
the UART, which is then completely disabled for the remainder of execution.

Text is output to the UART at 115,200 BAUD, 8 bit, no parity.
Please note that text end-of-line is a newline (LF) character only.
Therefore, the UART terminal must be set to simulate a CR/LF.


******************************************************************************


README.txt

Overview:

This is an adaptation of the TrustZone CryptoCell-312 runtime library from
ARM. The original source code can be found at:

https://github.com/ARM-software/cryptocell-312-runtime

The mbedTLS and cc312 libraries work together to provide implementations of
common cryptographic functions supported by the ARM cryptocell hardware,
using a common API provided by mbedTLS.

The version of cc312 provided here has been modified in a few ways to help
facilitate integration with systems using Ambiq Apollo4 devices.
Specifically we have made the following changes:

	- Added configuration options in the cc312 build scripts to support Apollo4
	- Added mbedTLS configuration headers to accomodate Apollo4 ports of
	  cc312 and mbedTLS for supported operating systems.
	- Added a new script to assist with building the cc312 and mbedTLS
	  library in known configurations.
	- Several small tweaks to the HAL/PAL porting layers to allow for easier
	  replacement of C stdlib functions.

Integration with existing code:

To access the cc312 and mbedTLS functionality from your project, you must add
the following libraries and include paths.

	Required libraries:
	- mbedtls/library/libmbedtls.a: mbedTLS functions
	- mbedtls/library/libmbedcrypto.a: Abstraction layer mapping mbedTLS to cc312
	- host/lib/libcc_312.a: Hardware-supported crypto functions.
	- host/lib/libpal_X.a (where X is a supported OS option): Hardware and
	  platform abstration layers (HAL and PAL) mapping cc312 functions to
	  hardware operations.

	Required include paths:
	- host/include (cc312 includes)
	- mbedtls/include (mbedTLS includes)
	- shared/include/pal (PAL includes)
	- shared/include/pal/X where "X" is a supported OS (Platform-specific includes)

Building libraries for your environment:

Several of the above libraries must be specically compiled to function within
a particular operating system or device. Both mbedTLS and cc312 provide build
scripts to help make this porting process easier. The standard distribution
provides build options for Linux, FreeRTOS, and baremetal build
configurations for a small number of supported devices. Ambiq has
specifically added configurations for Apollo4 for supported operating systems. 

Ambiq has also added additional scripts to help ensure that all of the
appropriate build options are set correctly.

Here are the instructions for rebuilding cc312 + mbedTLS for each option
using GCC and a bash or bash-like environment.

	Bare metal:
		1. Delete mbedtls folder.
		2. Open "set_env_for_gcc.sh" and find the AMBIQ_ROOT variable. Make
		   sure this points to the location of the AmbiqSuite software you
		   are using.
		3. Run "source set_env_for_gcc.sh" (Ambiq script to set environment
		   variables for the next step.)
		4. ./prepare_mbedtls.sh clone
		5. ./prepare_mbedtls.sh lib
		6. make -C host/src/pal ARM_CPU=$ARM_CPU TEE_OS=$TEE_OS
README.txt for the SEGGER RTT Implementation Pack.

MDK-ARM specifics:
https://wiki.segger.com/Keil_MDK-ARM#RTT_in_uVision

Included files:
===============
Root Directory
  - Examples
    - Main_RTT_InputEchoApp.c    - Sample application which echoes input on Channel 0.
    - Main_RTT_MenuApp.c         - Sample application to demonstrate RTT bi-directional functionality.
    - Main_RTT_PrintfTest.c      - Sample application to test RTT small printf implementation.
    - Main_RTT_SpeedTestApp.c    - Sample application for measuring RTT performance. embOS needed.
  - RTT
    - SEGGER_RTT.c                - The RTT implementation.
    - SEGGER_RTT.h                - Header for RTT implementation.
    - SEGGER_RTT_Conf.h           - Pre-processor configuration for the RTT implementation.
    - SEGGER_RTT_Printf.c         - Simple implementation of printf to write formatted strings via RTT.
  - Syscalls
    - RTT_Syscalls_GCC.c          - Low-level syscalls to retarget printf() to RTT with GCC / Newlib.
    - RTT_Syscalls_IAR.c          - Low-level syscalls to retarget printf() to RTT with IAR compiler.
    - RTT_Syscalls_KEIL.c         - Low-level syscalls to retarget printf() to RTT with KEIL/uVision compiler.
    - RTT_Syscalls_SES.c          - Low-level syscalls to retarget printf() to RTT with SEGGER Embedded Studio.
micro-ecc
==========

A small and fast ECDH and ECDSA implementation for 8-bit, 32-bit, and 64-bit processors.

The old version of micro-ecc can be found in the "old" branch.

Features
--------

 * Resistant to known side-channel attacks.
 * Written in C, with optional GCC inline assembly for AVR, ARM and Thumb platforms.
 * Supports 8, 32, and 64-bit architectures.
 * Small code size.
 * No dynamic memory allocation.
 * Support for 4 standard curves: secp160r1, secp192r1, secp256r1, and secp256k1.
 * BSD 2-clause license.

Usage Notes
-----------
### Point Representation ###
Compressed points are represented in the standard format as defined in http://www.secg.org/collateral/sec1_final.pdf; uncompressed points are represented in standard format, but without the `0x04` prefix. `uECC_make_key()`, `uECC_shared_secret()`, `uECC_sign()`, and `uECC_verify()` only handle uncompressed points; you can use `uECC_compress()` and `uECC_decompress()` to convert between compressed and uncompressed point representations.

Private keys are represented in the standard format.

### Using the Code ###

I recommend just copying (or symlink) uECC.h, uECC.c, and the appropriate asm\_&lt;arch&gt;\_.inc (if any) into your project. Then just `#include "uECC.h"` to use the micro-ecc functions.

For use with Arduino, you can just create a symlink to the `uECC` directory in your Arduino `libraries` directory. You can then use uECC just like any other Arduino library (uECC should show up in the **Sketch**=>**Import Library** submenu).

See uECC.h for documentation for each function.

### Compilation Notes ###

 * Should compile with any C/C++ compiler that supports stdint.h (this includes Visual Studio 2013).
 * If you want to change the defaults for `uECC_CURVE` and `uECC_ASM`, you must change them in your Makefile or similar so that uECC.c is compiled with the desired values (ie, compile uECC.c with `-DuECC_CURVE=uECC_secp256r1` or whatever).
 * When compiling for a Thumb-1 platform with inline assembly enabled (ie, `uECC_ASM` is defined to `uECC_asm_small` or `uECC_asm_fast`), you must use the `-fomit-frame-pointer` GCC option (this is enabled by default when compiling with `-O1` or higher).
 * When compiling for an ARM/Thumb-2 platform with fast inline assembly enabled (ie, `uECC_ASM` is defined to `uECC_asm_fast`), you must use the `-fomit-frame-pointer` GCC option (this is enabled by default when compiling with `-O1` or higher).
 * When compiling for AVR with inline assembly enabled, you must have optimizations enabled (compile with `-O1` or higher).
 * When building for Windows, you will need to link in the `advapi32.lib` system library.

ARM Performance
---------------

All tests were built using gcc 4.8.2 with `-O3`, and were run on a Raspberry Pi B+. `uECC_ASM` was defined to `uECC_asm_fast` and `ECC_SQUARE_FUNC` was defined to `1` in all cases. All times are in milliseconds.

<table>
	<tr>
		<th></th>
		<th>secp160r1</th>
		<th>secp192r1</th>
		<th>secp256r1</th>
		<th>secp256k1</th>
	</tr>
	<tr>
		<td><em>ECDH:</em></td>
		<td>2.3</td>
		<td>2.7</td>
		<td>7.9</td>
		<td>6.5</td>
	</tr>
	<tr>
		<td><em>ECDSA sign:</em></td>
		<td>2.8</td>
		<td>3.1</td>
		<td>8.6</td>
		<td>7.2</td>
	</tr>
	<tr>
		<td><em>ECDSA verify:</em></td>
		<td>2.7</td>
		<td>3.2</td>
		<td>9.2</td>
		<td>7.0</td>
	</tr>
</table>

AVR Performance
---------------

All tests were built using avr-gcc 4.8.1 with `-Os`, and were run on a 16 MHz ATmega256RFR2. Code size refers to the space used by micro-ecc code and data.

#### ECDH (fast) ####

In these tests, `uECC_ASM` was defined to `uECC_asm_fast` and `ECC_SQUARE_FUNC` was defined to `1` in all cases.

<table>
	<tr>
		<th></th>
		<th>secp160r1</th>
		<th>secp192r1</th>
		<th>secp256r1</th>
		<th>secp256k1</th>
	</tr>
	<tr>
		<td><em>ECDH time (ms):</em></td>
		<td>470</td>
		<td>810</td>
		<td>2220</td>
		<td>1615</td>
	</tr>
	<tr>
		<td><em>Code size (bytes):</em></td>
		<td>10768</td>
		<td>13112</td>
		<td>20886</td>
		<td>21126</td>
	</tr>
</table>

#### ECDH (small) ####

In these tests, `uECC_ASM` was defined to `uECC_asm_small` and `ECC_SQUARE_FUNC` was defined to `0` in all cases.

<table>
	<tr>
		<th></th>
		<th>secp160r1</th>
		<th>secp192r1</th>
		<th>secp256r1</th>
		<th>secp256k1</th>
	</tr>
	<tr>
		<td><em>ECDH time (ms):</em></td>
		<td>1250</td>
		<td>1810</td>
		<td>4790</td>
		<td>4700</td>
	</tr>
	<tr>
		<td><em>Code size (bytes):</em></td>
		<td>3244</td>
		<td>3400</td>
		<td>5274</td>
		<td>3426</td>
	</tr>
</table>

#### ECDSA (fast) ####

In these tests, `uECC_ASM` was defined to `uECC_asm_fast` and `ECC_SQUARE_FUNC` was defined to `1` in all cases.

<table>
	<tr>
		<th></th>
		<th>secp160r1</th>
		<th>secp192r1</th>
		<th>secp256r1</th>
		<th>secp256k1</th>
	</tr>
	<tr>
		<td><em>ECDSA sign time (ms):</em></td>
		<td>555</td>
		<td>902</td>
		<td>2386</td>
		<td>1773</td>
	</tr>
	<tr>
		<td><em>ECDSA verify time (ms):</em></td>
		<td>590</td>
		<td>990</td>
		<td>2650</td>
		<td>1800</td>
	</tr>
	<tr>
		<td><em>Code size (bytes):</em></td>
		<td>13246</td>
		<td>14798</td>
		<td>22594</td>
		<td>22826</td>
	</tr>
</table>

#### ECDSA (small) ####

In these tests, `uECC_ASM` was defined to `uECC_asm_small` and `ECC_SQUARE_FUNC` was defined to `0` in all cases.

<table>
	<tr>
		<th></th>
		<th>secp160r1</th>
		<th>secp192r1</th>
		<th>secp256r1</th>
		<th>secp256k1</th>
	</tr>
	<tr>
		<td><em>ECDSA sign time (ms):</em></td>
		<td>1359</td>
		<td>1931</td>
		<td>4998</td>
		<td>4904</td>
	</tr>
	<tr>
		<td><em>ECDSA verify time (ms):</em></td>
		<td>1515</td>
		<td>2160</td>
		<td>5700</td>
		<td>5220</td>
	</tr>
	<tr>
		<td><em>Code size (bytes):</em></td>
		<td>5690</td>
		<td>5054</td>
		<td>6980</td>
		<td>5080</td>
	</tr>
</table>
